\chapter{Lecteur de cartes}
Afin de vérifier l'assiduité des élèves lors des conférences nous mettons en
place un système de badge.

Il nous fallait une solution alliant plusieurs critères comme un coût et temps
de développement réduit et de la fabilité.

\newpage



\section{Historique}
Dès le début du projet Monsieur Berry nous a proposé plusieurs pistes à 
explorer pour le badge en lui même. Il fallait que chaque participant aux
conférences puisse être identifié de manière unique:

\begin{itemize}
\item Money Kart: C'est une entreprise basée près de Grenoble, spécialisée
dans la création de cartes à puce, notamment Moneo. L'avantage de cette solution
résidait dans la design des cartes. On aurait pu les faire graver
de façon à faire un buzz autour de la Semaine du Numérique. De plus la société
vendait également des lecteurs prêts à l'emploi.
Malheuresement, il nous fût impossible d'obtenir un devis de la part d'un
commercial, même après de multiples relance. Cette solution nécéssitait aussi
un investissement financier.

\item Carte étudiantes: Rapidement cette solution à fait l'unanimité. En effet,
elle était bien plus facile à mettre en place: chaque titulaire de carte délivrée
par l'UM2 possède un numéro unique, appelé numéro Mifare, accessible grâce à
la technologie RFID. Or Polytech possède une base de donnée faisant le lien entre
ce numéro et les élèves.
\end{itemize}

\section{RFID et Mifare}
RFID, de l'anglais ``radio frequency identification'' est une techonlogie 
mise au point pour permettre de lire à distance des données contenues dans des
marqueurs, étiquettes RFID.

    \begin{figure}[h]
        \begin{center}
            \includegraphics[scale=0.6]{RFIDtag.jpg} 
        \end{center}

        \caption{Etiquette RFID}
        \label{Etiquette RFID}
    \end{figure}


C'est une technologie employée quotidiennement par tout le monde puisqu'elle
sert entre autre à:

\begin{itemize}
\item Passeport bimométrique français.
\item Accès transport public, comme le tramway de Montpellier.
\item Inventaires.
\end{itemize}

Mifare est une des technologies de carte à puce sans contact les plus répandues
dans le monde avec 3,5 milliards de cartes et 40 millions de modules de lecture/encodage.

Ces deux technologies respectent des normes ISO.




\section{MFR120U}
    Rapidement après le début du projet, Mr Berry nous à mis en contact avec Mr
Cathebras, directeur du département ERII à Polytech'. En effet, il souhaitait lui
aussi mettre en place un système de présence informatisé, pour éviter de devoir
le faire sur papier, avant de le repporter sur l'ordinateur.

    Or il avait déjà creusé de son côté, puisqu'il avait acheté un lecteur de carte 
Mifare, appellé module MFR120U, pour la somme de 120\euro. Ce lecteur présentait néanmoins
plusieurs inconvénients majeurs:

    \begin{itemize}
        \item Programme d'utilisation exclusivemment sous les plateformes Windows.
        \item Liaison série-USB avec l'ordinateur par cable, ce qui nécessitait 
              à l'utilisateur d'installer un driver fournis également que pour
              Windows.
        \item Difficulté à savoir si la lecture de la carte avait réussi ou non.
    \end{itemize}

    Mr Cathebras avait donc demandé à un de ses collègues de travail du département
ERII, Mr Tamby, s'il pouvait concevoir un module qui répondrait plus à ses attentes.
De notre côté nous devions nous occuper de toute la partie software.

    C'est ici que nous intervenont. Début février 2012 nous avons recontré Mr Cathebras,
et nous avons pû discuter de l'interêt commun à développer un tel lecteur. En effet,
s'il venait à faire ces preuves en plus lors des conférences, il pourrait ce voir
industrialisé afin de voir son utilisation généralisé à Polytech. Il nous à donc
confié le MFR120U pour que nous puissions nous faire la main dessus.

    De plus il nous a fourni la documentation du lecteur. Or celle-ci nous fût d'un
grand secour par la suite puisqu'elle comprenait tout le protocole de communication
utilisé par le lecteur, ainsi que de nombreuses autres caractéristiques.

    \begin{itemize}
        \item Fabricant de la puce: Prolific Technology Inc. Les drivers pour Windows
              et MacOS X sont disponibles sur leur site web \cite{prolific}.
        \item Baud rate: 19200.
        \item Communication série 8N1 : 8 bits de donnés, aucun de parité, et 1 de stop.
        \item Possibilité de lire les cartes Mifare, mais pas que.
        \item En interne, le lecteur possède une mémoire capable de stocker 8000
              lectures de badge (date, heure, et informations de lus sur la carte).
    \end{itemize}

    Le programme que nous devions développer était en somme assez simple, puisqu'il
devait offrir une interface permettant de se connecter au lecteur, de récupérer les
données contenues suivant certains critères, les supprimer en mémoires si nécéssaire,
et enfin les envoyer sur une base de données distante.

    La version fonctionnelle pour le MFR120U (sans l'envoie en base de données)
est disponible dans le repository git sous le tag v0.9-mfr120u.


\section{Protocole de communication}




\section{Caractère multi-plateformes}
    Afin de répondre à la demande multi-plateforme des professeurs, nous nous 
sommes naturellement tourné vers le language C++. En effet, celui-ci offre un accès
proche de la machine, intéréssant pour la communication série notamment. De plus,
un étudiant ERII 3, Arthur Hiairrassary, à mis à notre disposition la bibliothèque
pour faire transiter des informations séries.

    Par contre nous sommes partis sur l'utilisation du nouveau standart C++11. Ainsi
dans le code nous trouvons l'utilisation:

    \begin{itemize}
        \item Variadics templtes.
        \item Fonctions lambdas.
        %\item std::function, std::bind, std::shared_ptr.
    \end{itemize}

    L'inconvénient de cela est bien sur le support par les compilateurs de cette
norme. Par exemple, msvc, le compilateur de Microsoft, ne prends en charge que peut
de ces fonctionnalités, et n'est donc pas à même de compiler le code, même avec la
beta de Visual Studio 2011.

    Néanmoins l'utilisation de ce standard nous à permis de s'affranchir de nombreuses
restrictions, et par conséquent un développement plus rapide, mais surtout bien
plus sûr. En effet la S(T)L est bien plus avancée.

    De plus l'inconvénient dû au compilateur msvc fût de courte durée puisqu'il
existe g++ et clang++, qui eux supportent en grande partie le nouveau standard.
Et en plus ils sont multi-plateformes! Le programme à pour l'instant été testé 
avec succès dans les conditions suivantes:

    \begin{itemize}
        \item Windows 7, 64 bits, MinGW 4.6.1
        \item MacOS X 10.7, 64 bits, clang++ 3.0 (sous machine virtuelle)
        \item Linux >= 3.1, 64 bits, g++-4.6
    \end{itemize}

    Afin de permettre une compilation aisée sur toutes ces plateformes, nous avons
optés pour l'utilisation de CMake afin de générer l'ensemble de l'environnement de
façon automatique.



\section{Prototype}
    Début décembre nous avons pû rencontrer Mr Tamby, en charge de développer le
prototype du nouveau lecteur. Durant la notre première réunion, il nous à donné
bon nombres de renseignements et conseils. De notre côté, nous lui avons fournis
l'ensemble des commandes que nous souhaitions retrouvées dans le prototype final.

    Aux alentours de mi-avril, il nous invite donc à voir le premier prototype.

% Photo du proto ici :)

    Nous sommes alors très surpris par le respect dont Mr Tamby à fait preuve
durant la réalisation du module, tant au niveau électronique que firmware.
En effet il n'aura fallut changer que le baud rate, ainsi que quelques lignes
pour que le programme soit opérationnel pour ce lecteur!

\section{Modélisation}
\section{Utilisation}
\section{Recommandations}
